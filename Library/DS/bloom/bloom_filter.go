package main

import (
	"bytes"
	"encoding/binary"
	"math"
	"sync"
)

// 布隆过滤器工作原理参考
// 1. https://juejin.cn/post/6844904007790673933
// 2. https://zh.wikipedia.org/wiki/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8

// 加盐 hash
const salt = "g9hmj2fhgr"

type Options struct {
	locker sync.Locker
}

type Option func(opt *Options)

func WithGoroutineSafe() Option {
	return func(opt *Options) {
		opt.locker = &sync.Mutex{}
	}
}

type BloomFilter struct {
	m      uint64
	k      uint64
	b      *Bitmap
	locker sync.Locker
}

func NewBloomFilter(m, k uint64, opts ...Option) *BloomFilter {
	opt := Options{
		locker: &sync.Mutex{},
	}

	for _, o := range opts {
		o(&opt)
	}

	return &BloomFilter{
		m:      m,
		k:      k,
		b:      NewBitMap(m),
		locker: opt.locker,
	}
}

// EstimateParameters estimates m and k from n and p
func EstimateParameters(n uint64, p float64) (m uint64, k uint64) {
	m = uint64(math.Ceil(-1 * float64(n) * math.Log(p) / (math.Ln2 * math.Ln2)))
	k = uint64(math.Ceil(math.Ln2 * float64(m) / float64(n)))
	return m, k
}

// NewWithEstimates creates a new BloomFilter with n and fp.
// n is the capacity of the BloomFilter
// fp is the tolerated error rate of the BloomFilter（允许错误率）
func NewWithEstimates(n uint64, fp float64, opts ...Option) *BloomFilter {
	m, k := EstimateParameters(n, fp)
	return NewBloomFilter(m, k, opts...)
}

// NewFromData creates a new BloomFilter from data generated by function 'Data()'
func NewFromData(data []byte, opts ...Option) *BloomFilter {
	opt := Options{
		locker: &sync.Mutex{},
	}
	for _, o := range opts {
		o(&opt)
	}
	b := &BloomFilter{
		locker: opt.locker,
	}

	reader := bytes.NewReader(data)
	binary.Read(reader, binary.LittleEndian, &b.m) // 8byte
	binary.Read(reader, binary.LittleEndian, &b.k) // 8byte
	b.b = NewBitMapFromData(data[8+8:])
	return b
}

// func (bf *BloomFilter) Add(val string) {
// 	bf.locker.Lock()
// 	defer bf.locker.Unlock()

// 	hashs := hash.GenHashInts([]byte(salt+val), int(bf.k))
// 	for i := uint64(0); i < bf.k; i++ {
// 		bf.b.Set(hashs[i] % bf.m)
// 	}
// }

// // Contains returns true if val is (high probability) in the BloomFilter, otherwise returns false.
// func (bf *BloomFilter) Contains(val string) bool {
// 	bf.locker.RLock()
// 	defer bf.locker.RUnlock()

// 	hashs := hash.GenHashInts([]byte(salt+val), int(bf.k))
// 	for i := uint64(0); i < bf.k; i++ {
// 		if !bf.b.IsSet(hashs[i] % bf.m) {
// 			return false
// 		}
// 	}
// 	return true
// }

// // Data returns the data of the BloomFilter, it can bee used to creates a new BloomFilter by using function 'NewFromData' .
// func (bf *BloomFilter) Data() []byte {
// 	bf.locker.Lock()
// 	defer bf.locker.Unlock()

// 	buf := new(bytes.Buffer)
// 	binary.Write(buf, binary.LittleEndian, bf.m)
// 	binary.Write(buf, binary.LittleEndian, bf.k)
// 	buf.Write(bf.b.Data())
// 	return buf.Bytes()
// }

func main() {

}
