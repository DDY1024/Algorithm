package main

// 一. 置换（循环节）
// https://blog.csdn.net/lfb637/article/details/86653121
// 注意: 可以任意交换两个位置的元素，最终使得数组变为有序
// 给定一个包含1-n的数列，通过 [交换任意两个元素] 给数列重新排序。求最少需要多少次交换，能把数组排成按1-n递增的顺序，（数组中的元素互不重复）。
//
// 解题思路:
// 1. 找原位置与排序后位置不一致的形成交换环
// 例如
// 		2, 4, 3, 6, 5, 7
// 		2, 3, 4, 5, 6, 7
// 存在 4, 3 和 6, 5 两个交换环
//
// 2. 一个交换环变成有序的最少交换次数为 "环的长度-1" 次
// 3. 总的最少交换次数 = m个交换环的总长度 - m

// 二、数组逆序对数（相邻两两交换）
//
// 题目大意：给定一个序列 a, 每次【只允许交换相邻两个数】, 最少要交换多少次才能把它变成非递降序列？
//
// 结论: 最少两两交换次数即为数组中逆序对的个数（a[i] > a[j] && i < j）
//
// 求解数组中逆序对的个数，我们可以采用下面两种方式
// 1. 归并排序求解逆序对数
// 2. 利用树状数组求解逆序对数

// 三、快速排序算法
// https://blog.csdn.net/wthfeng/article/details/78037228
//
// 1. 在数组中选一个基准数（通常为数组第一个）
// 2. 将数组中小于基准数的数据移到基准数左边，大于基准数的移到右边
// 3. 对于基准数左、右两边的数组，不断重复以上两个过程，直到每个子集只有一个元素，即为全部有序
func quickSort(arr []int, low, high int) {
	if low >= high {
		return
	}

	i, j, base := low, high, arr[low]
	for i < j {
		for i < j && arr[j] >= base {
			j--
		}
		if i < j {
			arr[i] = arr[j]
			i++
		}
		for i < j && arr[i] <= base {
			i++
		}
		if i < j {
			arr[j] = arr[i]
			j--
		}
	}
	arr[i] = base
	quickSort(arr, low, i-1)
	quickSort(arr, i+1, high)
}
